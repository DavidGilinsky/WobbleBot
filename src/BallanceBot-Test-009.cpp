//============================================================================
// Name        : BallanceBot-Test-009.cpp
// Author      : David Gilinsky
// Version     :
// Copyright   : Your copyright notice
// Description :
//============================================================================

#include <iostream>
#include <iomanip>
#include <cstdlib>
#include <sys/time.h>
#include <pigpio.h>
#include <pthread.h>
#include <csignal>
#include <signal.h>
#include <mutex>
#include <thread>
#include <atomic>
#include <libconfig.h++>
#include <string>
#include "Navio/gpio.h"
#include "Navio/PCA9685.h"
#include "Navio/Util.h"
#include "Navio/MPU9250.h"
#include "Sensors/Encoder.h"
#include "AHRS.hpp"
#include "RTIMULib.h"
#include "bThread.h"

std::mutex data; //lock for bThread data

pthread_t bThread_num;

// initialize the public data structure for the ballance thread
bThread_struct bThread;

//  Using RTIMULib here allows it to use the .ini file generated by RTIMULibDemo.
//  Or, you can create the .ini in some other directory by using:
//      RTIMUSettings *settings = new RTIMUSettings("<directory path>", "RTIMULib");
//  where <directory path> is the path to where the .ini file is to be loaded/saved

RTIMUSettings *settings = new RTIMUSettings("RTIMULib");
RTIMU *imu = RTIMU::createIMU(settings);



// Objects

//MPU9250 imu;    // MPU9250
AHRS    ahrs;   // Mahony AHRS
Encoder	encoder; // Interface to Arduino i2c wheel encoder

libconfig::Config cfg; // configuration file object (libconfig)

// Timing data for IMU

float offset[3];
struct timeval tv;
float dt, maxdt;
float mindt = 0.01;
unsigned long previoustime, currenttime;
//float dtsumm = 0;
int isFirst = 1;

int readConfig(void* arg){
	bThread_struct* bThread = (bThread_struct*)arg;

	std::string str1;

	printf("Reading BB.cfg\n");

	cfg.setOptions(1);

	try
	{
		cfg.readFile("BB.cfg");
	}
	catch(const libconfig::FileIOException &fioex)
	  {
	    std::cerr << "I/O error while reading file." << std::endl;
	    return(EXIT_FAILURE);
	  }
	catch(const libconfig::ParseException &pex)
	  {
	    std::cerr << "Parse error at " << pex.getFile() << ":" << pex.getLine()
	              << " - " << pex.getError() << std::endl;
	    return(EXIT_FAILURE);
	  }

	const libconfig::Setting& root = cfg.getRoot();


	try
	{
		printf("Setting PID Parameters.\n");

		const libconfig::Setting &PIDs = root["PID"];

		int count=PIDs.getLength();
		double temp=0.0;

		printf("Found %d PIDs\n",count);

		for(int i=0;i<count;i++){
			const libconfig::Setting &PID=PIDs[i];
			str1=PID.getName();
			printf("%s\n",PID.getName());
			if(str1.compare("balance")==0){
				printf("Setting PID_balance parameters.\n");
				bThread->PID_balance.windup_guard=PID["windup_guard"];
				bThread->PID_balance.proportional_gain=PID["proportional_gain"];
				bThread->PID_balance.integral_gain=PID["integral_gain"];
				bThread->PID_balance.derivative_gain=PID["derivative_gain"];
			}
			if(str1.compare("motor_1")==0){
				printf("Setting PID_motor_1 parameters.\n");
				bThread->PID_motor_1.windup_guard=PID["windup_guard"];
				bThread->PID_motor_1.proportional_gain=PID["proportional_gain"];
				bThread->PID_motor_1.integral_gain=PID["integral_gain"];
				bThread->PID_motor_1.derivative_gain=PID["derivative_gain"];
			}
			if(str1.compare("motor_2")==0){
				printf("Setting PID_motor_2 parameters.\n");
				bThread->PID_motor_2.windup_guard=PID["windup_guard"];
				bThread->PID_motor_2.proportional_gain=PID["proportional_gain"];
				bThread->PID_motor_2.integral_gain=PID["integral_gain"];
				bThread->PID_motor_2.derivative_gain=PID["derivative_gain"];
			}
			if(str1.compare("position_1")==0){
				printf("Setting PID_position_1 parameters.\n");
				bThread->PID_position_1.windup_guard=PID["windup_guard"];
				bThread->PID_position_1.proportional_gain=PID["proportional_gain"];
				bThread->PID_position_1.integral_gain=PID["integral_gain"];
				bThread->PID_position_1.derivative_gain=PID["derivative_gain"];

			}
			if(str1.compare("position_2")==0){
				printf("Setting PID_position_2 parameters.\n");
				bThread->PID_position_2.windup_guard=PID["windup_guard"];
				bThread->PID_position_2.proportional_gain=PID["proportional_gain"];
				bThread->PID_position_2.integral_gain=PID["integral_gain"];
				bThread->PID_position_2.derivative_gain=PID["derivative_gain"];

			}
			if(str1.compare("bodyV")==0){
				printf("Setting PID_bodyV parameters.\n");
				bThread->PID_bodyV.windup_guard=PID["windup_guard"];
				bThread->PID_bodyV.proportional_gain=PID["proportional_gain"];
				bThread->PID_bodyV.integral_gain=PID["integral_gain"];
				bThread->PID_bodyV.derivative_gain=PID["derivative_gain"];

			}
			if(str1.compare("wheelV")==0){
				printf("Setting PID_wheelV parameters.\n");
				bThread->PID_wheelV.windup_guard=PID["windup_guard"];
				bThread->PID_wheelV.proportional_gain=PID["proportional_gain"];
				bThread->PID_wheelV.integral_gain=PID["integral_gain"];
				bThread->PID_wheelV.derivative_gain=PID["derivative_gain"];

			}
			if(str1.compare("yaw")==0){
				printf("Setting PID_yaw parameters.\n");
				bThread->PID_yaw.windup_guard=PID["windup_guard"];
				bThread->PID_yaw.proportional_gain=PID["proportional_gain"];
				bThread->PID_yaw.integral_gain=PID["integral_gain"];
				bThread->PID_yaw.derivative_gain=PID["derivative_gain"];
			}

			int count2=PID.getLength();
			for(int x=0;x<count2;x++){
				temp=PID[x];
				printf("\t%s=%f\n",PID[x].getName(),temp);
				}
		}



	}
	catch(const libconfig::SettingNotFoundException &nfex)
	  {
	    // Ignore.
	  }
		printf("m1ig: %f m2ig: %f\n",bThread->PID_motor_1.integral_gain,bThread->PID_motor_2.integral_gain);
	return 0;


}

void setupThreadData(bThread_struct *bt) {
	data.lock();
	bt->motor_left_pin=3;
	bt->motor_right_pin=4;
	bt->motor_left_in1=3;
	bt->motor_left_in2=4;
	bt->motor_right_in1=5;
	bt->motor_right_in2=6;
	bt->motor_stop=0;
	bt->motor_forward_full=4096;
	bt->motor_backward_full=-4096;
	bt->G_SI=9.80665;
	bt->PI=3.14159;
	bt->MOTORS_ENABLED=true;
	bt->mindt=.01;
	bt->minDeltaT=0;
	bt->dtsumm = 0;
	bt->isFirst = 1;
	bt->targetPitch=0;

	bt->PID_motor_1.windup_guard=1;
	bt->PID_motor_1.proportional_gain=100;
	bt->PID_motor_1.integral_gain=900;
	bt->PID_motor_1.derivative_gain=0;

	bt->PID_motor_2.windup_guard=1;
	bt->PID_motor_2.proportional_gain=100;
	bt->PID_motor_2.integral_gain=800;
	bt->PID_motor_2.derivative_gain=0;

	bt->PID_position_1.windup_guard=0;
	bt->PID_position_1.proportional_gain=0;
	bt->PID_position_1.integral_gain=0;
	bt->PID_position_1.derivative_gain=0;

	bt->PID_position_2.windup_guard=0;
	bt->PID_position_2.proportional_gain=-0;
	bt->PID_position_2.integral_gain=0;
	bt->PID_position_2.derivative_gain=0;

	bt->PID_bodyV.windup_guard=1;
	bt->PID_bodyV.proportional_gain=.06;
	bt->PID_bodyV.integral_gain=.2;
	bt->PID_bodyV.derivative_gain=0;

	bt->PID_wheelV.windup_guard=1;
	bt->PID_wheelV.proportional_gain=0;
	bt->PID_wheelV.integral_gain=0;
	bt->PID_wheelV.derivative_gain=0;

	bt->PID_yaw.windup_guard=0;
	bt->PID_yaw.proportional_gain=0;
	bt->PID_yaw.integral_gain=0;
	bt->PID_yaw.derivative_gain=0;
	data.unlock();
}

// PID functions
void pid_zeroize(PID* pid) {
    // set prev and integrated error to zero
    pid->prev_error = 0;
    pid->int_error = 0;
}

void pid_update(PID* pid, double curr_error, double dt) {
    double diff;
    double p_term;
    double i_term;
    double d_term;


    // integration with windup guarding
    pid->int_error += (curr_error * dt);
/*    if (pid->int_error < -(pid->windup_guard))
        pid->int_error = -(pid->windup_guard);
    else if (pid->int_error > pid->windup_guard)
        pid->int_error = pid->windup_guard;*/

    // differentiation
    diff = ((curr_error - pid->prev_error) / dt);

    // scaling
    p_term = (pid->proportional_gain * curr_error);
    i_term = (pid->integral_gain     * pid->int_error);
    d_term = (pid->derivative_gain   * diff);


//    printf("Prev Error: %f\tError: %f\tdeltaT: %f\ti_term: %f\tint_error: %f\n",pid->prev_error,curr_error,dt,i_term,pid->int_error);

    // summation of terms
    pid->control = p_term + i_term + d_term;

/*    printf("dt: %f\tcurr_error: %f\tint_error %f\tp_term: %f\ti_term: %f\td_term: %f\tContro: %f\n",
    		dt,
    		curr_error,
			pid->int_error,
    		p_term,
			i_term,
			d_term,
			pid->control);*/

    // save current error as previous error for next iteration
    pid->prev_error = curr_error;

}


//================================  PPM Options =====================================

unsigned int samplingRate      = 1;      // 1 microsecond (can be 1,2,4,5,10)
unsigned int ppmInputGpio      = 4;      // PPM input on Navio's 2.54 header
unsigned int ppmSyncLength     = 4000;   // Length of PPM sync pause
unsigned int ppmChannelsNumber = 7;      // Number of channels packed in PPM
unsigned int servoFrequency    = 50;     // Servo control frequency
bool verboseOutputEnabled      = false;   // Output channels values to console
unsigned int ppmChannelsUsed	= 2;
//============================ Objects & data ==================================

PCA9685 pwm;
float channels[8];
float targetPitch=0;

//============================== PPM decoder ===================================

/*
double motor_left_speed=motor_stop;
double motor_right_speed=motor_stop;
*/

unsigned int currentChannel = 0;
unsigned int previousTick;
unsigned int deltaTime;

float round_func(float f, int y){
	return std::floor(f*pow(10,y))/pow(10,y);
}

void ppmOnEdge(int gpio, int level, uint32_t tick)
{
    using namespace Navio;

	if (level == 0) {
                deltaTime = tick - previousTick;
                previousTick = tick;

                if (deltaTime >= ppmSyncLength) { // Sync
                        currentChannel = 0;

                        // RC output
                        for (uint i = 0; i < ppmChannelsNumber; i++) {
//                            pwm.setPWMuS(i + 3, channels[i]); // 1st Navio RC output is 3
                        if (i==1) {
                        	if(channels[i]>1000 and channels[i]<2000){
                        		targetPitch=(1500-channels[i])*.001;
                        	}
                        }

                        }
                        // Console output
                        if (verboseOutputEnabled) {
                                printf("\r");
                                for (uint i = 0; i < ppmChannelsNumber; i++)
                                        printf("%4.f ", channels[i]);
                        }
                }
                else
                        if (currentChannel < ppmChannelsNumber)
                                channels[currentChannel++] = deltaTime;
        }
}

// AHRS Functions

void imuSetup()
{
	data.lock();

    bThread.IMUsampleCount = 0;
    bThread.IMUsampleRate = 0;

        //  Using RTIMULib here allows it to use the .ini file generated by RTIMULibDemo.
        //  Or, you can create the .ini in some other directory by using:
        //      RTIMUSettings *settings = new RTIMUSettings("<directory path>", "RTIMULib");
        //  where <directory path> is the path to where the .ini file is to be loaded/saved


        if ((imu == NULL) || (imu->IMUType() == RTIMU_TYPE_NULL)) {
            printf("No IMU found\n");
            exit(1);
        }

        //  This is an opportunity to manually override any settings before the call IMUInit

        //  set up IMU

        imu->IMUInit();

        //  this is a convenient place to change fusion parameters

        imu->setSlerpPower(0.02);
        imu->setGyroEnable(true);
        imu->setAccelEnable(true);
        imu->setCompassEnable(true);

        //  set up for rate timer

//        bThread.IMUrateTimer = bThread.IMUdisplayTimer = RTMath::currentUSecsSinceEpoch();

        data.unlock();
}

void imuLoop(void* arg)
{
	bThread_struct* bThread = (bThread_struct*)arg;
	data.lock();
	bThread->prev_pitch=bThread->pitch;
    while(imu->IMURead()){
         bThread->imuData = imu->getIMUData();

        if(bThread->imuData.fusionPoseValid){
            bThread->IMUdisplayTimer = bThread->IMUnow;
            bThread->roll=bThread->imuData.fusionPose.x() * RTMATH_RAD_TO_DEGREE;
            bThread->pitch=(round_func(bThread->imuData.fusionPose.y() * RTMATH_RAD_TO_DEGREE,4));
            bThread->yaw=round_func(bThread->imuData.fusionPose.z() * RTMATH_RAD_TO_DEGREE,1);
            if(bThread->yaw<0) bThread->yaw+=360.0;
        }
    }
    data.unlock();
}

// Signal Handler



void sig_handler(int signo)
{
	void *p_status;
  if (signo == SIGINT or signo == 2){
    printf("received SIGINT. Stopping motors.\n");
    bThread.EXIT_THREAD=true;
    if(bThread.MOTORS_ENABLED){

    	    		pwm.setPWMuS(bThread.motor_left_in1, 0);
    	    		pwm.setPWMuS(bThread.motor_right_in1, 0);

    	    		pwm.setPWMuS(bThread.motor_left_in2, 0);
    	    		pwm.setPWMuS(bThread.motor_right_in2, 0);

    	    	}
    pthread_join(bThread_num,&p_status);
    std::exit(0);
  }
}

void getWheelEncoderData(void *arg){
bThread_struct* bThread = (bThread_struct*)arg;

	data.lock();

/*	float wheel_1_speedArray[3];
	float wheel_1_speedAvg;
	int wheelSpeedCount=0;
	float wheel_2_speedArray[3];
	float wheel_2_speedAvg;*/

	bThread->wheelSpeedCount=0;

	bThread->wheel_1_new=encoder.getWheel_1()*.028125;
	bThread->wheel_2_new=encoder.getWheel_2()*.028125;


	if(abs(bThread->wheel_1_position-bThread->wheel_1_new)<=45) {
		bThread->wheel_1_delta=bThread->wheel_1_position-bThread->wheel_1_new;
		bThread->wheel_1_position=bThread->wheel_1_new;
	} else {
		bThread->wheel_1_new = bThread->wheel_1_position;

	}
	if(abs(bThread->wheel_2_position-bThread->wheel_2_new)<=45) {
		bThread->wheel_2_delta=bThread->wheel_2_position-bThread->wheel_2_new;
	   	bThread->wheel_2_position=bThread->wheel_2_new;
  	} else {
  		bThread->wheel_2_new = bThread->wheel_2_position;
   	}

	if(bThread->wheel_1_delta != 0 && bThread->wheel_2_delta !=0){
  	bThread->wheel_1_speedArray[bThread->wheelSpeedCount] = (bThread->wheel_1_delta)/bThread->dtsumm.load(std::memory_order_seq_cst);
   	bThread->wheel_2_speedArray[bThread->wheelSpeedCount] = (bThread->wheel_2_delta)/bThread->dtsumm.load(std::memory_order_seq_cst);
   	if(bThread->wheelSpeedCount==0) {
   		bThread->wheel_1_speedAvg = bThread->wheel_1_speedArray[bThread->wheelSpeedCount];
   		bThread->wheel_2_speedAvg = bThread->wheel_2_speedArray[bThread->wheelSpeedCount];
   	}
   	if(bThread->wheelSpeedCount>0){
   		bThread->wheel_1_speedAvg = (bThread->wheel_1_speedAvg + bThread->wheel_1_speedArray[bThread->wheelSpeedCount])/bThread->wheelSpeedCount+1;
   		bThread->wheel_2_speedAvg = (bThread->wheel_2_speedAvg + bThread->wheel_2_speedArray[bThread->wheelSpeedCount])/bThread->wheelSpeedCount+1;
   	}
	    	if(bThread->wheelSpeedCount<19) bThread->wheelSpeedCount++;
	    	if(bThread->wheelSpeedCount==20) bThread->wheelSpeedCount=0;

	    bThread->wheel_1_speed=bThread->wheel_1_speedAvg;
	    bThread->wheel_2_speed=bThread->wheel_2_speedAvg;
	}

//   	bThread->wheel_1_speed=(bThread->wheel_1_delta)/bThread->dtsumm.load(std::memory_order_seq_cst);
//  	bThread->wheel_2_speed=(bThread->wheel_2_delta)/bThread->dtsumm.load(std::memory_order_seq_cst);

   	data.unlock();

}

void calcBodySpeed(void *arg){
	bThread_struct* bThread = (bThread_struct*)arg;


	data.lock();



	bThread->body_delta=bThread->prev_pitch-bThread->pitch;

// calculate body speed

	bThread->body_speed = (bThread->body_delta/bThread->dtsumm.load(std::memory_order_seq_cst));

	/*printf("prevP: %f curP: %f bd: %f dt: %f w1s: %f bs: %f\n",
				bThread->prev_pitch,
				bThread->pitch,
				bThread->body_delta,
				bThread->dtsumm.load(std::memory_order_seq_cst),
				bThread->wheel_1_speed,
				bThread->body_speed);
*/
	data.unlock();
}

void setStartingPitch(void* arg){
	bThread_struct* bThread = (bThread_struct*)arg;

	imuLoop(bThread);

	while(!bThread->imuData.fusionPoseValid){
	// wait for valid IMU Data
	}

	bThread->prev_pitch=bThread->pitch;

	printf("Starting pitch set. %f\n",
			bThread->prev_pitch);

}

void checkStanding(void* arg){
	bThread_struct* bThread = (bThread_struct*)arg;
	data.lock();

	if(bThread->MOTORS_ENABLED) {
	    		if(bThread->lyingDown==true) {
	    			if(bThread->mainTV.tv_sec - bThread->startTime > 1) {
	    				std::cout<<"Checking pitch." << abs(bThread->pitch)<<"\n";
	    				if(abs(bThread->pitch)>=10.0) {
	    					std::printf("Standup failed after %lu seconds. Pitch: %3.2f\n",
	    							bThread->mainTV.tv_sec - bThread->startTime,
									bThread->pitch);
	    					data.unlock();
	    					sig_handler(SIGINT);
	    				} else if(abs(bThread->pitch)<10.0) {
	    					bThread->lyingDown=false;
	    					printf("Standing. Setting pitch failsafe to 20.\n");
	    				}
	    			}
	    		}
	    	}
	data.unlock();
}

void runPIDs(void* arg){
	data.lock();

	bThread_struct* bThread = (bThread_struct*)arg;

	bThread->wheel_1_position_error=bThread->wheel_1_new;
	bThread->wheel_2_position_error=bThread->wheel_2_new;

	pid_update(&bThread->PID_position_1,bThread->wheel_1_position_error,bThread->dtsumm.load(std::memory_order_seq_cst));
	pid_update(&bThread->PID_position_2,bThread->wheel_2_position_error,bThread->dtsumm.load(std::memory_order_seq_cst));

	pid_update(&bThread->PID_bodyV,bThread->body_speed,bThread->dtsumm.load(std::memory_order_seq_cst));

	pid_update(&bThread->PID_wheelV,bThread->wheel_1_speed,bThread->dtsumm.load(std::memory_order_seq_cst));

	pid_update(&bThread->PID_yaw,bThread->yaw,bThread->dtsumm.load(std::memory_order_seq_cst));

//	bThread->balance_error=((bThread->pitch)-(bThread->PID_bodyV.control)+(bThread->PID_wheelV.control)+(bThread->PID_position_1.control));
	bThread->balance_error=((bThread->pitch)-(bThread->PID_position_1.control)-(bThread->PID_bodyV.control));

	pid_update(&bThread->PID_balance,bThread->balance_error,bThread->dtsumm.load(std::memory_order_seq_cst));

	bThread->motor_1_error=bThread->PID_balance.control;
	bThread->motor_2_error=bThread->PID_balance.control;

/*	bThread->motor_1_error=(bThread->pitch
			+bThread->PID_position_1.control
					+bThread->PID_bodyV.control)
					-bThread->PID_wheelV.control;

	bThread->motor_2_error=(bThread->pitch
	    			+bThread->PID_position_2.control
	    					+bThread->PID_bodyV.control)
							-bThread->PID_wheelV.control;*/


	pid_update(&bThread->PID_motor_1,bThread->motor_1_error,bThread->dtsumm.load(std::memory_order_seq_cst));
	pid_update(&bThread->PID_motor_2,bThread->motor_2_error,bThread->dtsumm.load(std::memory_order_seq_cst));

	data.unlock();

}

void runMotors(void* arg){
	bThread_struct* bThread = (bThread_struct*)arg;

	data.lock();

	bThread->motor_1_pwm=abs(bThread->PID_motor_1.control);
	bThread->motor_2_pwm=abs(bThread->PID_motor_2.control);


	if(abs(bThread->pitch)>bThread->failsafePitch){
		bThread->motor_speed_1_in1=0;
		bThread->motor_speed_1_in2=0;
		bThread->motor_speed_2_in1=0;
		bThread->motor_speed_2_in2=0;
		bThread->lyingDown=true;

	} else {

		if(bThread->PID_motor_1.control>0){
			bThread->motor_speed_1_in2=bThread->motor_2_pwm;
			bThread->motor_speed_1_in1=0;
		} else if(bThread->PID_motor_1.control<0){
			bThread->motor_speed_1_in2=0;
			bThread->motor_speed_1_in1=bThread->motor_1_pwm;
		}

		if(bThread->PID_motor_2.control>0){
			bThread->motor_speed_2_in2=bThread->motor_2_pwm;
			bThread->motor_speed_2_in1=0;
		} else if(bThread->PID_motor_1.control<0){
			bThread->motor_speed_2_in2=0;
			bThread->motor_speed_2_in1=bThread->motor_2_pwm;
		}

		if(bThread->motor_speed_1_in1 >4096) bThread->motor_speed_1_in1=4096;
		if(bThread->motor_speed_1_in2 >4096) bThread->motor_speed_1_in2=4096;
		if(bThread->motor_speed_1_in1 < -4096) bThread->motor_speed_1_in1=-4096;
		if(bThread->motor_speed_1_in2 < -4096) bThread->motor_speed_1_in2=-4096;

		if(bThread->motor_speed_2_in1 >4096) bThread->motor_speed_2_in1=4096;
		if(bThread->motor_speed_2_in2 >4096) bThread->motor_speed_2_in2=4096;
		if(bThread->motor_speed_2_in1 < -4096) bThread->motor_speed_2_in1=-4096;
		if(bThread->motor_speed_2_in2 < -4096) bThread->motor_speed_2_in2=-4096;
	}




		if(bThread->MOTORS_ENABLED){
		pwm.setPWMuS(bThread->motor_left_in1, bThread->motor_speed_1_in1);
		pwm.setPWMuS(bThread->motor_right_in1, bThread->motor_speed_1_in1);

		pwm.setPWMuS(bThread->motor_left_in2, bThread->motor_speed_2_in2);
		pwm.setPWMuS(bThread->motor_right_in2, bThread->motor_speed_2_in2);

	}
		data.unlock();
}

void *timingTest_func(void* arg){
	bThread_struct* bThread = (bThread_struct*)arg;

	if (signal(SIGINT, sig_handler) == SIG_ERR)
		  printf("\ncan't catch SIGINT\n");

	bThread->dtsumm.store(0,std::memory_order_seq_cst);

	gettimeofday(&bThread->mainTV,NULL);
	bThread->currentMainTime.store(1000000 * bThread->mainTV.tv_sec + bThread->mainTV.tv_usec,std::memory_order_seq_cst);
	bThread->previousMainTime.store(bThread->currentMainTime.load(std::memory_order_seq_cst),std::memory_order_seq_cst);
	bThread->startTime=bThread->mainTV.tv_sec;

	printf("In timingTest_func\n");

	// set prev_pitch before entring loop for calculation of delatas

	setStartingPitch(bThread);

	while(!bThread->EXIT_THREAD){

		gettimeofday(&bThread->mainTV,NULL);
		bThread->currentMainTime.store(1000000 * bThread->mainTV.tv_sec + bThread->mainTV.tv_usec,std::memory_order_seq_cst);
		bThread->deltaT.store((bThread->currentMainTime.load() - bThread->previousMainTime.load()) / 1000000.0,std::memory_order_seq_cst);
		bThread->dtsumm.store(bThread->dtsumm.load(std::memory_order_seq_cst)+bThread->deltaT.load(std::memory_order_seq_cst),std::memory_order_seq_cst);



		if(bThread->dtsumm.load(std::memory_order_seq_cst)>.001){



		imuLoop(bThread);

		getWheelEncoderData(bThread);

		calcBodySpeed(bThread);

		if(bThread->imuData.fusionPoseValid){

			checkStanding(bThread);

			runPIDs(bThread);

			runMotors(bThread);
/*

			printf("prev: %lu cur: %lu dtsumm: %f deltaT: %Lf imu: %d\n",
				bThread->previousMainTime.load(std::memory_order_seq_cst),
				bThread->currentMainTime.load(std::memory_order_seq_cst),
				bThread->dtsumm.load(std::memory_order_seq_cst),
				bThread->deltaT.load(std::memory_order_seq_cst),
				bThread->imuData.fusionPoseValid);

*/


			printf("a: %f bs: %f p: %f be: %f bc: %f mc: %f\n",
					bThread->pitch,
					bThread->body_speed,
					bThread->wheel_1_position,
					bThread->balance_error,
					bThread->PID_balance.control,
					bThread->PID_motor_1.control
					);

/*

			printf("Pitch: %f w1: %f w2: %f w1s: %f w2s: %f m1p: %f m2p: %f\n",
					bThread->pitch,
					bThread->wheel_1_position,
					bThread->wheel_2_position,
					bThread->wheel_1_speed,
					bThread->wheel_2_speed,
					bThread->motor_1_pwm,
					bThread->motor_2_pwm);

*/




/*
			printf("w1: %f w2: %f w1s: %f w2s: %f p1c: %f p2c: %f m1c: %f m2c: %f\n",
					bThread->wheel_1_position,
					bThread->wheel_2_position,
					bThread->wheel_1_speed,
					bThread->wheel_2_speed,
					bThread->PID_position_1.control,
					bThread->PID_position_2.control,
					bThread->PID_motor_1.control,
					bThread->PID_motor_2.control);

*/

/*			printf("pc: %f posC: %f bc: %f wc: %f m1c: %f m2c: %f m1p: %f m2p: %f\n",
					bThread->pitch,
					bThread->PID_position_1.control,
					bThread->PID_bodyV.control,
					bThread->PID_wheelV.control,
					bThread->PID_motor_1.control,
					bThread->PID_motor_2.control,
					bThread->motor_1_pwm,
					bThread->motor_2_pwm);*/
			fflush(stdout);
		}

			bThread->dtsumm.store(0.0,std::memory_order_seq_cst);
		}


		bThread->previousMainTime.store(bThread->currentMainTime.load(std::memory_order_seq_cst),std::memory_order_seq_cst);
		usleep(500);
	}

	// stop motors before exiting the thread
	 if(bThread->MOTORS_ENABLED){
	    	pwm.setPWMuS(bThread->motor_left_in1, 0);
	    	pwm.setPWMuS(bThread->motor_right_in1, 0);

	    	pwm.setPWMuS(bThread->motor_left_in2, 0);
	    	pwm.setPWMuS(bThread->motor_right_in2, 0);
	 }
	return NULL;
}

void *bThread_func(void* arg){
	bThread_struct* bThread = (bThread_struct*)arg;
	float bodySpeedArray[3];
	float bodySpeedAvg;
	int bodySpeedCount=0;
	float wheel_1_speedArray[3];
	float wheel_1_speedAvg;
	int wheelSpeedCount=0;
	float wheel_2_speedArray[3];
	float wheel_2_speedAvg;

	std::atomic<double> deltaT;
//	unsigned long previousMainTime,currentMainTime = 0;
	std::atomic<unsigned long> previousMainTime;
	std::atomic<unsigned long> currentMainTime;
	std::atomic<float> dtsumm;

	dtsumm.store(0,std::memory_order_seq_cst);

	printf("Balance Thread Starting\n");

	data.lock();

	gettimeofday(&bThread->mainTV,NULL);
	currentMainTime.store(1000000 * bThread->mainTV.tv_sec + bThread->mainTV.tv_usec,std::memory_order_seq_cst);
    previousMainTime.store(currentMainTime.load(std::memory_order_seq_cst),std::memory_order_seq_cst);

    while (!bThread->EXIT_THREAD) {

    	if(bThread->lyingDown==false){
    		bThread->failsafePitch=20;
    	}
        gettimeofday(&bThread->mainTV,NULL);
        currentMainTime.store(1000000 * bThread->mainTV.tv_sec + bThread->mainTV.tv_usec,std::memory_order_seq_cst);
        deltaT.store((currentMainTime.load(std::memory_order_seq_cst) - previousMainTime.load(std::memory_order_seq_cst)) / 1000000.0,std::memory_order_seq_cst);
    	dtsumm.store(deltaT.load(std::memory_order_seq_cst)+deltaT.load(std::memory_order_seq_cst),std::memory_order_seq_cst);

        if(bThread->isMainFirst==1){
            bThread->startTime=bThread->mainTV.tv_sec;
            std::printf("First time through main loop. %lu",bThread->startTime);
            bThread->isMainFirst=0;
        }

/*
        if (!bThread->isMainFirst)
            {
                if (bThread->deltaT > bThread->maxDeltaT) bThread->maxDeltaT = bThread->deltaT;
                if (bThread->deltaT < bThread->minDeltaT) bThread->minDeltaT = bThread->deltaT;

            }
*/
        printf("dt %f dtsum %f\n",
        		deltaT.load(std::memory_order_seq_cst),
				dtsumm.load(std::memory_order_seq_cst));

        if(dtsumm.load(std::memory_order_seq_cst)>.1) {
        	data.unlock();
//        	imuLoop();
        	data.lock();
        if(bThread->imuData.fusionPoseValid){


// Get wheel encoder data
    	bThread->wheel_1_new=encoder.getWheel_1()*.028125;
    	bThread->wheel_2_new=encoder.getWheel_2()*.028125;


    	if(abs(bThread->wheel_1_position-bThread->wheel_1_new)<=45) {
    		bThread->wheel_1_delta=bThread->wheel_1_position-bThread->wheel_1_new;
    		bThread->wheel_1_position=bThread->wheel_1_new;
    	} else {
    		bThread->wheel_1_new = bThread->wheel_1_position;

    	}
    	if(abs(bThread->wheel_2_position-bThread->wheel_2_new)<=45) {
    	bThread->wheel_2_delta=bThread->wheel_2_position-bThread->wheel_2_new;
    	bThread->wheel_2_position=bThread->wheel_2_new;
    	} else {
    		bThread->wheel_2_new = bThread->wheel_2_position;
    	}

    	wheel_1_speedArray[wheelSpeedCount] = (bThread->wheel_1_delta)/deltaT;
    	wheel_2_speedArray[wheelSpeedCount] = (bThread->wheel_2_delta)/deltaT;
    	if(wheelSpeedCount==0) {
    		wheel_1_speedAvg = wheel_1_speedArray[wheelSpeedCount];
    		wheel_2_speedAvg = wheel_2_speedArray[wheelSpeedCount];
    	}
    	if(wheelSpeedCount>0){
    		wheel_1_speedAvg = (wheel_1_speedAvg + wheel_1_speedArray[wheelSpeedCount])/wheelSpeedCount+1;
    		wheel_2_speedAvg = (wheel_2_speedAvg + wheel_2_speedArray[wheelSpeedCount])/wheelSpeedCount+1;
    	}
//    	if(wheelSpeedCount<2) wheelSpeedCount++;
//    	if(wheelSpeedCount==3) wheelSpeedCount=0;

    	bThread->wheel_1_speed=wheel_1_speedAvg;
    	bThread->wheel_2_speed=wheel_2_speedAvg;


//    	bThread->wheel_1_speed=(bThread->wheel_1_delta*.028125)/bThread->deltaT;
//    	bThread->wheel_2_speed=(bThread->wheel_2_delta*.028125)/bThread->deltaT;

    	bThread->body_delta=bThread->prev_pitch-bThread->pitch;

	// calculate body speed

    	bodySpeedArray[bodySpeedCount] = (bThread->body_delta/deltaT)-bThread->wheel_1_speed;
    	if(bodySpeedCount==0) bodySpeedAvg= bodySpeedArray[bodySpeedCount];
    	if(bodySpeedCount>0) bodySpeedAvg = (bodySpeedAvg + bodySpeedArray[bodySpeedCount])/bodySpeedCount+1;
    	if(bodySpeedCount<2) bodySpeedCount++;
    	if(bodySpeedCount==3) bodySpeedCount=0;

    	bThread->body_speed=bodySpeedAvg;
//    	bThread->body_speed=((bThread->prev_pitch-bThread->pitch)/bThread->deltaT)-bThread->wheel_1_speed;
 /*   	printf("prev_pitch: %3.2f pitch: %3.2f dt: %f bs: %f\n",
    			bThread->prev_pitch,
				bThread->pitch,
				bThread->deltaT,
				bThread->body_speed);
*/
    	if(bThread->MOTORS_ENABLED) {
    		if(bThread->lyingDown==true) {
    			if(bThread->mainTV.tv_sec - bThread->startTime > 1) {
    				if(abs(bThread->pitch)>10) {
    					std::printf("Standup failed after %lu seconds. Pitch: %3.2f\n",
    							bThread->mainTV.tv_sec - bThread->startTime,
								bThread->pitch);
    					sig_handler(SIGINT);
    				} else if(abs(bThread->pitch)<10) {
    					bThread->lyingDown=false;
    					printf("Standing. Setting pitch failsafe to 20.\n");
    				}
    			}
    		}
    	}
// increasing the offset tilts toward ethernet jack

    	bThread->wheel_1_position_error=bThread->wheel_1_new/1600.0;
    	bThread->wheel_2_position_error=bThread->wheel_2_new/1600.0;

    	data.unlock(); // release the lock to allow pid_update to grab it

    	pid_update(&bThread->PID_position_1,bThread->wheel_1_position_error,deltaT);
    	pid_update(&bThread->PID_position_2,bThread->wheel_2_position_error,deltaT);

    	pid_update(&bThread->PID_bodyV,bThread->body_speed,deltaT);

    	pid_update(&bThread->PID_wheelV,bThread->wheel_1_speed,deltaT);

    	pid_update(&bThread->PID_yaw,bThread->yaw,deltaT);

//   		bThread->motor_1_error=bThread->pitch-bThread->PID_position_1.control+bThread->PID_bodyV.control;
//    	bThread->motor_1_error=bThread->pitch-bThread->PID_position_1.control;

    	data.lock();

    	bThread->motor_1_error=(bThread->pitch
    			+bThread->PID_position_1.control
    					+bThread->PID_bodyV.control)
						-bThread->PID_wheelV.control;

    	bThread->motor_2_error=(bThread->pitch
    	    			+bThread->PID_position_2.control
    	    					+bThread->PID_bodyV.control)
    							-bThread->PID_wheelV.control;

    	data.unlock(); // release the lock to let pid_update grab it

    	pid_update(&bThread->PID_motor_1,bThread->motor_1_error,deltaT);
    	pid_update(&bThread->PID_motor_2,bThread->motor_2_error,deltaT);

    	data.lock();

    	bThread->motor_1_pwm=abs(bThread->PID_motor_1.control/100*4096);
    	bThread->motor_2_pwm=abs(bThread->PID_motor_2.control/100*4096);

    	if(bThread->isMainFirst==true){
    		bThread->motor_pwm_1_prev=bThread->motor_1_pwm;
    		bThread->motor_pwm_2_prev=bThread->motor_1_pwm;
    	}

    	if(bThread->pwm_avg_count==1){
    		bThread->motor_1_pwm=(bThread->motor_pwm_1_prev+bThread->motor_1_pwm)/2;
    		bThread->motor_2_pwm=(bThread->motor_pwm_2_prev+bThread->motor_2_pwm)/2;
    	}

    	if(abs(bThread->pitch)>bThread->failsafePitch){
    		bThread->motor_speed_1_in1=0;
    		bThread->motor_speed_1_in2=0;
    		bThread->motor_speed_2_in1=0;
    		bThread->motor_speed_2_in2=0;
    		bThread->lyingDown=true;

    	} else {

    		if(bThread->PID_motor_1.control>0){
    			bThread->motor_speed_1_in2=bThread->motor_2_pwm;
    			bThread->motor_speed_1_in1=0;
    		} else if(bThread->PID_motor_1.control<0){
    			bThread->motor_speed_1_in2=0;
    			bThread->motor_speed_1_in1=bThread->motor_1_pwm;
    		}

    		if(bThread->PID_motor_2.control>0){
    			bThread->motor_speed_2_in2=bThread->motor_2_pwm;
    			bThread->motor_speed_2_in1=0;
    		} else if(bThread->PID_motor_1.control<0){
    			bThread->motor_speed_2_in2=0;
    			bThread->motor_speed_2_in1=bThread->motor_2_pwm;
    		}

    		if(bThread->motor_speed_1_in1 >4096) bThread->motor_speed_1_in1=4096;
    		if(bThread->motor_speed_1_in2 >4096) bThread->motor_speed_1_in2=4096;
    		if(bThread->motor_speed_1_in1 < -4096) bThread->motor_speed_1_in1=-4096;
    		if(bThread->motor_speed_1_in2 < -4096) bThread->motor_speed_1_in2=-4096;

    		if(bThread->motor_speed_2_in1 >4096) bThread->motor_speed_2_in1=4096;
    		if(bThread->motor_speed_2_in2 >4096) bThread->motor_speed_2_in2=4096;
    		if(bThread->motor_speed_2_in1 < -4096) bThread->motor_speed_2_in1=-4096;
    		if(bThread->motor_speed_2_in2 < -4096) bThread->motor_speed_2_in2=-4096;
    	}



/*    	if(bThread->pwm_avg_count==1){
    		bThread->motor_speed_in1=(bThread->motor_speed_1_prev+bThread->motor_speed_in1)/2;
    		bThread->motor_speed_in2=(bThread->motor_speed_2_prev+bThread->motor_speed_in2)/2;
    		bThread->pwm_avg_count=-1;
    	}*/

    		if(bThread->MOTORS_ENABLED){
    		pwm.setPWMuS(bThread->motor_left_in1, bThread->motor_speed_1_in1);
    		pwm.setPWMuS(bThread->motor_right_in1, bThread->motor_speed_1_in1);

    		pwm.setPWMuS(bThread->motor_left_in2, bThread->motor_speed_2_in2);
    		pwm.setPWMuS(bThread->motor_right_in2, bThread->motor_speed_2_in2);

    	}




    	bThread->motor_pwm_1_prev=bThread->motor_1_pwm;
    	bThread->motor_pwm_2_prev=bThread->motor_2_pwm;

    	printf("prev_time: %lu cur_time: %lu Diff: %lu deltaT: %f\n",
    			previousMainTime.load(std::memory_order_seq_cst),
				currentMainTime.load(std::memory_order_seq_cst),
				currentMainTime.load(std::memory_order_seq_cst)-previousMainTime.load(std::memory_order_seq_cst),
				deltaT.load());
    	fflush(stdout);

  /*  	printf("dtsumm: %f dt: %f Prev-Pitch: %f Pitch: %f bd: %f bs: %f m1pwm: %lf m2pwm: %lf\n",
    			bThread->dtsumm,
				bThread->deltaT,
				bThread->prev_pitch,
				bThread->pitch,
				bThread->body_delta,
				bThread->body_speed,
				bThread->motor_1_pwm,
				bThread->motor_2_pwm);
*/
       bThread->isMainFirst = 0;
       bThread->pwm_avg_count++;
       dtsumm.store(0,std::memory_order_seq_cst);
       bThread->prev_pitch=bThread->pitch;



        } //fusion pose valid
        } //dtsumm > .1
        currentMainTime.store(1000000 * bThread->mainTV.tv_sec + bThread->mainTV.tv_usec,std::memory_order_seq_cst);
        previousMainTime.store(currentMainTime.load(std::memory_order_acquire),std::memory_order_acquire);
       data.unlock();
    }
    if(bThread->MOTORS_ENABLED){
    	pwm.setPWMuS(bThread->motor_left_in1, 0);
    	pwm.setPWMuS(bThread->motor_right_in1, 0);

    	pwm.setPWMuS(bThread->motor_left_in2, 0);
    	pwm.setPWMuS(bThread->motor_right_in2, 0);

    	    	}
	return NULL;
}

using namespace std;

int main() {

	bThread.isMainFirst=1;

	// register signal SIGINT and signal handler

	if (signal(SIGINT, sig_handler) == SIG_ERR)
		  printf("\ncan't catch SIGINT\n");

	if (signal(2, sig_handler) == SIG_ERR)
		  printf("\ncan't catch SIGINT\n");


	using namespace Navio;

	std::cout << "bBot 001 reporting for duty" << endl; // prints bBot 001 reporting for duty

	bThread.outputEnablePin = RPI_GPIO_27;


	setupThreadData(&bThread);


	readConfig(&bThread);

	Pin pin(bThread.outputEnablePin);

	if (pin.init()) {
	        pin.setMode(Pin::GpioModeOutput);
	        pin.write(0); /* drive Output Enable low */
	    } else {
	        fprintf(stderr, "Output Enable not set. Are you root?\n");
	        return 1;
	    }


	    pwm.initialize();

	    gpioCfgClock(samplingRate, PI_DEFAULT_CLK_PERIPHERAL, 0); // last parameter is deprecated now
	    gpioInitialise();
	    previousTick = gpioTick();
	    gpioSetAlertFunc(ppmInputGpio, ppmOnEdge);
	    gpioSetSignalFunc(SIGINT,sig_handler);

// IMU stuff
	    imuSetup();



	    bThread.motor_1_error=0;




	    pid_zeroize(&bThread.PID_motor_1);
	    pid_zeroize(&bThread.PID_position_1);
	    pid_zeroize(&bThread.PID_bodyV);
	    pid_zeroize(&bThread.PID_wheelV);

	    // Wait for Gyros to stabilize
	    int count=0;
	    while(count <500) {
	    	imuLoop(&bThread);
	    	count++;
	    }

	    bThread.prev_pitch=0;
	    bThread.prev_yaw=0;


	    bThread.lyingDown=true;
	    bThread.failsafePitch=30;

	    bThread.wheel_1_position_error=0.0;

    	printf("\n Gyros stabilized at Pitch: %3.2f Yaw: %3.2f\n",bThread.pitch,bThread.yaw);
    	printf("Resetting encoders.\n");

    	encoder.resetPosition();

/*    	if(abs(bThread.pitch)>10) {
    		bThread.lyingDown=true; // gonna use this to set the pitch failsafe in the loop
    		bThread.failsafePitch=30;
    		printf("Lying down. Setting failsafe pitch to 30\n");
    	}*/


	    bThread.motor_1_pwm=0;

	    bThread.pwm_avg_count=0;

// Create the balance thread



/*
	    if(pthread_create(&bThread_num,NULL,bThread_func,&bThread)) {
	    	printf("Error creating thread.\n");
	    }
*/




	    if(pthread_create(&bThread_num,NULL,timingTest_func,&bThread)) {
	    	printf("Error creating thread.\n");
	    }




	        //  now just process data

	        while (1) {
	            //  poll at the rate recommended by the IMU

//	            printf("roll:%f pitch:%f yaw:%f SR: %d\n",bThread.roll,bThread.pitch,bThread.yaw,bThread.IMUsampleRate);
//	            fflush(stdout);


	        	}



	return 0;
}


